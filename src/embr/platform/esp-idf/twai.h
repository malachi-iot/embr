#pragma once

#include <estd/internal/impl/streambuf.h>
#include <estd/streambuf.h>

#include "driver/twai.h"

namespace embr { namespace esp_idf {

namespace impl {

template <class TCharTraits>
class twai_streambuf_base : public estd::internal::impl::streambuf_base<TCharTraits>
{
protected:

    twai_message_t message;

    constexpr twai_streambuf_base() = default;

    constexpr twai_streambuf_base(const twai_message_t& message) :
        message(message)
    {}

    inline uint8_t* data() const
    {
        return const_cast<uint8_t*>(message.data);
    }

public:
    inline bool extd() const { return message.extd; }
    inline bool rtr() const { return message.rtr; }
    uint32_t identifier() const { return message.identifier; }
};

template <class TCharTraits, class TBase = twai_streambuf_base<TCharTraits> >
class itwai_streambuf :
    // DEBT: This tag really should also include an xsgetc bypass
    estd::internal::streambuf_gptr_tag,
    public TBase
{
    typedef TBase base_type;

    inline twai_message_t& message() { return base_type::message; }
    inline const twai_message_t& message() const { return base_type::message; }

    inline uint8_t data_length() const { return message().data_length_code & 0x0F; }

    inline uint8_t pos() const { return message().data_length_code >> 4; }
    inline void pos(uint8_t v)
    {
        message().data_length_code &= 0xF;
        message().data_length_code |= v << 4;
    }

public:
    typedef typename base_type::int_type int_type;
    typedef typename base_type::char_type char_type;

    constexpr itwai_streambuf() = default;

    /*
    constexpr itwai_streambuf(const twai_message_t& message) :
        base_type(message)
    {} */

    inline unsigned xin_avail() const { return data_length() - pos(); }

    inline char_type* eback() const { return reinterpret_cast<char_type*>(base_type::data()); }
    inline char_type* gptr() const { return eback() + pos(); }
    inline char_type* egptr() const { return eback() + data_length(); }

    inline char_type xsgetc() const { return *gptr(); }

    // UNTESTED
    inline void gbump(int count) { message().data_length_code += count << 4; }

    // NOTE: Leaning a bit more towards a 'Transport' type object, but a
    // wrapper API here is pretty harmless
    inline esp_err_t receive(TickType_t ticks_to_wait)
    {
        return twai_receive(&base_type::message, ticks_to_wait);
    }

    // UNTESTED
    inline esp_err_t receive(estd::chrono::freertos_clock::duration d)
    {
        return receive(d.count());
    }
};

template <class TCharTraits, class TBase = twai_streambuf_base<TCharTraits> >
class otwai_streambuf : public TBase
{
    typedef TBase base_type;

    inline twai_message_t& message() { return base_type::message; }
    inline const twai_message_t& message() const { return base_type::message; }

    inline uint8_t pos() const { return message().data_length_code; }
    inline void pos(uint8_t v) { message().data_length_code = v; }
    inline uint8_t maximum() const { return sizeof(base_type::message.data); }

public:
    typedef typename base_type::traits_type traits_type;
    typedef typename base_type::int_type int_type;
    typedef typename base_type::char_type char_type;

    otwai_streambuf()
    {
        // Deprecated, but very convenient way to initialize
        base_type::message.flags = 0;
        pos(0);
    }

    /*
    constexpr otwai_streambuf(const twai_message_t& message) :
        base_type(message)
    {} */

    inline char_type* pbase() const { return reinterpret_cast<char_type*>(base_type::data()); }
    inline char_type* pptr() const { return pbase() + pos(); }
    inline char_type* epptr() const { return pbase() + maximum(); }

    inline void pbump(int count) { message().data_length_code += count; }

    inline bool end() const { return pos() >= maximum(); }

    estd::streamsize xsputn(const char_type* s, estd::streamsize count)
    {
        /*
         * Nifty, but probably not any better than the simpler one below.
         * Still, may be worthwhile as an autogenerated or utility method
        char_type* const end = s + count;

        for(; s < end; ++s)
            if(sputc(*s) == traits_type::eof)
                return s - (end - count);

        return count; */
        int8_t remaining = maximum() - pos();

        if(count > remaining)
            count = remaining;

        estd::copy_n(s, count, pptr());
        pbump(count);
        return count;
    }

    // NOTE: Might be able to put this into helper-realm, though it's a bit of
    // the cure being worse than the disease -- may be more confusing to have
    // those helpers around rather than copy/paste this little chunk of code here
    inline int_type sputc(char_type c)
    {
        if(end()) return traits_type::eof();

        int_type r = *pptr();
        pbump(1);
        return r;
    }

    void ss(bool v) { message().ss = v; }
    void identifier(uint32_t v) { message().identifier = v; }

    // NOTE: Leaning a bit more towards a 'Transport' type object, but a
    // wrapper API here is pretty harmless
    inline esp_err_t transmit(TickType_t ticks_to_wait)
    {
        return twai_receive(&base_type::message, ticks_to_wait);
    }

    // UNTESTED
    inline esp_err_t transmit(estd::chrono::freertos_clock::duration d)
    {
        return transmit(d.count());
    }
};


}


template <class TChar, class TCharTraits = estd::char_traits<TChar> >
using basic_itwai_streambuf = estd::internal::streambuf<impl::itwai_streambuf<TCharTraits> >;

template <class TChar, class TCharTraits = estd::char_traits<TChar> >
using basic_otwai_streambuf = estd::internal::streambuf<impl::otwai_streambuf<TCharTraits> >;

typedef basic_itwai_streambuf<char> itwai_streambuf;
typedef basic_otwai_streambuf<char> otwai_streambuf;

}}